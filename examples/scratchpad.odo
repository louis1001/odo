#{
#{ At 10x10 this some seconds to complete.
 # An example of 10x10
 #
 # ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
 # • • ■ • • • • • • • ■ • • • ■ • • • • • ■
 # ■ • ■ ■ ■ ■ ■ • ■ • ■ • ■ • ■ ■ ■ ■ ■ • ■
 # ■ • • • • • ■ • ■ • • • ■ • • • • • • • ■
 # ■ ■ ■ ■ ■ • ■ • ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ • ■
 # ■ • • • ■ • • • ■ • • • • • • • • • ■ • ■
 # ■ • ■ • ■ ■ ■ ■ ■ • ■ ■ ■ ■ ■ ■ ■ • ■ • ■
 # ■ • ■ • • • • • • • ■ • • • • • ■ • ■ • ■
 # ■ • ■ ■ ■ • ■ ■ ■ ■ ■ • ■ ■ ■ • ■ ■ ■ • ■
 # ■ • • • ■ • • • • • • • ■ • • • ■ • • • ■
 # ■ ■ ■ • ■ ■ ■ ■ ■ ■ ■ ■ ■ • ■ ■ ■ • ■ ■ ■
 # ■ • ■ • ■ • • • • • • • ■ • ■ • • • ■ • ■
 # ■ • ■ • ■ • ■ ■ ■ • ■ ■ ■ • ■ • ■ ■ ■ • ■
 # ■ • • • ■ • • • ■ • • • ■ • ■ • • • ■ • ■
 # ■ • ■ ■ ■ ■ ■ ■ ■ ■ ■ • ■ • ■ ■ ■ • ■ • ■
 # ■ • ■ • • • • • ■ • • • ■ • • • ■ • • • ■
 # ■ • ■ • ■ ■ ■ • ■ • ■ • ■ ■ ■ • ■ ■ ■ • ■
 # ■ • ■ • ■ • ■ • • • ■ • ■ • ■ • • • • • ■
 # ■ • ■ • ■ • ■ ■ ■ ■ ■ • ■ • ■ ■ ■ ■ ■ ■ ■
 # ■ • • • ■ • • • • • • • • • • • • • • • •
 # ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■
 #
 }#

func to_percent(n: int, m: int): double {
    var cn = n / (m+0.0)
    return cn * 100
}

class Cell {
    var x: int
    var y: int
                             # up     right  down   left
    var walls             =  [ false, false, false, false]
    var neighbors: Cell[] =  [ null,  null,  null,  null ]

    var visited = false

    init(x_: int, y_: int) {
        x = x_
        y = y_
    }
}

class Neighbor {
    var cell: Cell
    var dir: int
    init(c_: Cell, dir_: int) { cell = c_; dir = dir_ }
}

class Maze {
    var width: int = 1
    var height: int = 1

# I'm not handling this syntax for bi-dimensional lists.
    var cells: Cell[][] = []

    func find_neighbors(x: int, y: int): Cell[] {
        var ns: Cell[] = [null, null, null, null]

        if y > 0 {
            ns[0] = cells[y-1][x]
        }
        if x > 0 {
            ns[1] = cells[y][x-1]
        }

        if y < height-1 {
            ns[2] = cells[y+1][x]
        }

        if x < width-1 {
            ns[3] = cells[y][x+1]
        }

        return ns
    }

    # TODO: Infer these types by the variable's use
    init(w: int, h: int) {
        width = w
        height = h

        cells = []#mu::create_matrix(w, h, func(int x, int y) -> new Cell(x, y))
        forange y: h {
            var row: Cell[] = []
            forange x: w {
                push(row, new Cell(x, y))
            }
            push(cells, row)
        }

# Debug this line. It should be working now.
        foreach row : cells {
            foreach c : row {
                c.neighbors = this.find_neighbors(c.x, c.y)
            }
        }
    }

    static func choose(lst: Neighbor[]): Neighbor {
        var rnd_index = randInt(0, length(lst))

        return lst[rnd_index]
    }

    func generate() {
        var initial = cells[0][0];

        var stack = [initial]
        initial.visited = true
        var n_visited = 1
        var max_visit = width * height

        while length(stack) > 0 {
            # Need to fine a way of knowing what type will pop have
            var current: Cell = pop(stack)
            write("Generating Maze: ", trunc(to_percent(n_visited, max_visit)), "%\r")

            var possible_neighbors: Neighbor[] = []

            var i = 0
            foreach neigh_cell : current.neighbors {
                if (neigh_cell != null) {
                    if (!neigh_cell.visited) {
                        push(possible_neighbors, new Neighbor(neigh_cell, i))
                    }
                }

                i++
            }

            var neigh_amount = length(possible_neighbors)

            if (neigh_amount > 0) {
                stack += current
                var next = this::choose(possible_neighbors)

                current.walls[next.dir] = true
                next.cell.walls[(next.dir+2)%4] = true
                next.cell.visited = true
                n_visited++

                stack += next.cell
            }
        }
    }

    func print_maze(x = 0, y = 0) {
        writeln()
        var canvas_height = height*2+1
        var canvas_width = width*2+1

        var path_spaces = " "
        var wall_char = "0"

        var b: string[][] = [[wall_char]*canvas_width]*canvas_height

        var canvas_max = canvas_width*canvas_height
        var counter = 0

        foreach row : cells {
            foreach c : row {
                var x = c.x*2 + 1
                var y = c.y*2 + 1

                b[y][x] = path_spaces

                var ws = c.walls
                if ws[0] {
                    b[y - 1][x + 0] = path_spaces
                }
                if ws[1] or (c.x == 0 and c.y == 0){
                    b[y + 0][x - 1] = path_spaces
                }
                if ws[2] {
                    b[y + 1][x + 0] = path_spaces
                }
                if ws[3] or (c.x == width-1 and c.y == height-1){
                    b[y + 0][x + 1] = path_spaces
                }
            }
        }

        foreach row : b {
            foreach char : row {
                write(char, " ")
            }
            writeln()
        }
    }
}

var w = 40
var h = 40

var main = new Maze(w, h)
main.generate()
main.print_maze()
}#
# Find all fibonacci numbers up to n and store them in a list
var n = 1000

var a = 1
var b = 0
var c = 0

# List expression infers it's type from the first element in it
# I need to define a currently accepted list type in SemAn
# When visitind ListDeclaration
# So that an empty list returns a valid value
# And lists with incompatible types aren't accepted.

var results: int[] = []

while c < n {
    b = a
    a = c
    c = a + b

    results += c
}

forange i : length(results) {
    writeln("[", i, "]:\t", results[i])
}

writeln()
writeln("Testing a separator")
writeln("v^"*50)

writeln("Testing a list with some repeating values")
writeln([0]*20)
